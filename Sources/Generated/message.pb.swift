// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///* Type of hashing scheme used to produce a digest of MessageData 
public enum HashScheme: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case none // = 0

  /// Default scheme for hashing MessageData
  case blake3 // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .blake3
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .blake3: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension HashScheme: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [HashScheme] = [
    .none,
    .blake3,
  ]
}

#endif  // swift(>=4.2)

///* Type of signature scheme used to sign the Message hash  
public enum SignatureScheme: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case none // = 0

  /// Ed25519 signature (default)
  case ed25519 // = 1

  /// ECDSA signature using EIP-712 scheme 
  case eip712 // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .ed25519
    case 2: self = .eip712
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .ed25519: return 1
    case .eip712: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SignatureScheme: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SignatureScheme] = [
    .none,
    .ed25519,
    .eip712,
  ]
}

#endif  // swift(>=4.2)

///* Type of the MessageBody 
public enum MessageType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case none // = 0

  /// Add a new Cast
  case castAdd // = 1

  /// Remove an existing Cast
  case castRemove // = 2

  /// Add a Reaction to a Cast
  case reactionAdd // = 3

  /// Remove a Reaction from a Cast
  case reactionRemove // = 4

  /// Add a new Link
  case linkAdd // = 5

  /// Remove an existing Link
  case linkRemove // = 6

  /// Add a Verification of an Ethereum Address
  case verificationAddEthAddress // = 7

  /// Remove a Verification
  case verificationRemove // = 8

  /// Add a new Ed25519 key pair that signs messages for a user
  case signerAdd // = 9

  /// Remove an Ed25519 key pair that signs messages for a user
  case signerRemove // = 10

  /// Add metadata about a user
  case userDataAdd // = 11
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .castAdd
    case 2: self = .castRemove
    case 3: self = .reactionAdd
    case 4: self = .reactionRemove
    case 5: self = .linkAdd
    case 6: self = .linkRemove
    case 7: self = .verificationAddEthAddress
    case 8: self = .verificationRemove
    case 9: self = .signerAdd
    case 10: self = .signerRemove
    case 11: self = .userDataAdd
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .castAdd: return 1
    case .castRemove: return 2
    case .reactionAdd: return 3
    case .reactionRemove: return 4
    case .linkAdd: return 5
    case .linkRemove: return 6
    case .verificationAddEthAddress: return 7
    case .verificationRemove: return 8
    case .signerAdd: return 9
    case .signerRemove: return 10
    case .userDataAdd: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MessageType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MessageType] = [
    .none,
    .castAdd,
    .castRemove,
    .reactionAdd,
    .reactionRemove,
    .linkAdd,
    .linkRemove,
    .verificationAddEthAddress,
    .verificationRemove,
    .signerAdd,
    .signerRemove,
    .userDataAdd,
  ]
}

#endif  // swift(>=4.2)

///* Farcaster network the message is intended for 
public enum FarcasterNetwork: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case none // = 0

  /// Public primary network
  case mainnet // = 1

  /// Public test network
  case testnet // = 2

  /// Private test network
  case devnet // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .mainnet
    case 2: self = .testnet
    case 3: self = .devnet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .mainnet: return 1
    case .testnet: return 2
    case .devnet: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FarcasterNetwork: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FarcasterNetwork] = [
    .none,
    .mainnet,
    .testnet,
    .devnet,
  ]
}

#endif  // swift(>=4.2)

///* Type of UserData 
public enum UserDataType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case none // = 0

  /// Profile Picture for the user
  case pfp // = 1

  /// Display Name for the user
  case display // = 2

  /// Bio for the user
  case bio // = 3

  /// URL of the user
  case url // = 5

  /// Preferred Farcaster Name for the user
  case fname // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .pfp
    case 2: self = .display
    case 3: self = .bio
    case 5: self = .url
    case 6: self = .fname
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .pfp: return 1
    case .display: return 2
    case .bio: return 3
    case .url: return 5
    case .fname: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension UserDataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [UserDataType] = [
    .none,
    .pfp,
    .display,
    .bio,
    .url,
    .fname,
  ]
}

#endif  // swift(>=4.2)

///* Type of Reaction 
public enum ReactionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case none // = 0

  /// Like the target cast
  case like // = 1

  /// Share target cast to the user's audience
  case recast // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .like
    case 2: self = .recast
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .like: return 1
    case .recast: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ReactionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ReactionType] = [
    .none,
    .like,
    .recast,
  ]
}

#endif  // swift(>=4.2)

///* 
/// A Message is a delta operation on the Farcaster network. The message protobuf is an envelope 
/// that wraps a MessageData object and contains a hash and signature which can verify its authenticity. 
public struct Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contents of the message
  public var data: MessageData {
    get {return _data ?? MessageData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  /// Hash digest of data
  public var hash: Data = Data()

  /// Hash scheme that produced the hash digest
  public var hashScheme: HashScheme = .none

  /// Signature of the hash digest
  public var signature: Data = Data()

  /// Signature scheme that produced the signature
  public var signatureScheme: SignatureScheme = .none

  /// Public key or address of the key pair that produced the signature
  public var signer: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: MessageData? = nil
}

///* 
/// A MessageData object contains properties common to all messages and wraps a body object which 
/// contains properties specific to the MessageType.
public struct MessageData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of message contained in the body 
  public var type: MessageType = .none

  /// Farcaster ID of the user producing the message
  public var fid: UInt64 = 0

  /// Farcaster epoch timestamp in seconds
  public var timestamp: UInt32 = 0

  /// Farcaster network the message is intended for
  public var network: FarcasterNetwork = .none

  public var body: MessageData.OneOf_Body? = nil

  public var castAddBody: CastAddBody {
    get {
      if case .castAddBody(let v)? = body {return v}
      return CastAddBody()
    }
    set {body = .castAddBody(newValue)}
  }

  public var castRemoveBody: CastRemoveBody {
    get {
      if case .castRemoveBody(let v)? = body {return v}
      return CastRemoveBody()
    }
    set {body = .castRemoveBody(newValue)}
  }

  public var reactionBody: ReactionBody {
    get {
      if case .reactionBody(let v)? = body {return v}
      return ReactionBody()
    }
    set {body = .reactionBody(newValue)}
  }

  public var verificationAddEthAddressBody: VerificationAddEthAddressBody {
    get {
      if case .verificationAddEthAddressBody(let v)? = body {return v}
      return VerificationAddEthAddressBody()
    }
    set {body = .verificationAddEthAddressBody(newValue)}
  }

  public var verificationRemoveBody: VerificationRemoveBody {
    get {
      if case .verificationRemoveBody(let v)? = body {return v}
      return VerificationRemoveBody()
    }
    set {body = .verificationRemoveBody(newValue)}
  }

  public var signerAddBody: SignerAddBody {
    get {
      if case .signerAddBody(let v)? = body {return v}
      return SignerAddBody()
    }
    set {body = .signerAddBody(newValue)}
  }

  public var userDataBody: UserDataBody {
    get {
      if case .userDataBody(let v)? = body {return v}
      return UserDataBody()
    }
    set {body = .userDataBody(newValue)}
  }

  public var signerRemoveBody: SignerRemoveBody {
    get {
      if case .signerRemoveBody(let v)? = body {return v}
      return SignerRemoveBody()
    }
    set {body = .signerRemoveBody(newValue)}
  }

  public var linkBody: LinkBody {
    get {
      if case .linkBody(let v)? = body {return v}
      return LinkBody()
    }
    set {body = .linkBody(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable {
    case castAddBody(CastAddBody)
    case castRemoveBody(CastRemoveBody)
    case reactionBody(ReactionBody)
    case verificationAddEthAddressBody(VerificationAddEthAddressBody)
    case verificationRemoveBody(VerificationRemoveBody)
    case signerAddBody(SignerAddBody)
    case userDataBody(UserDataBody)
    case signerRemoveBody(SignerRemoveBody)
    case linkBody(LinkBody)

  #if !swift(>=4.1)
    public static func ==(lhs: MessageData.OneOf_Body, rhs: MessageData.OneOf_Body) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.castAddBody, .castAddBody): return {
        guard case .castAddBody(let l) = lhs, case .castAddBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.castRemoveBody, .castRemoveBody): return {
        guard case .castRemoveBody(let l) = lhs, case .castRemoveBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reactionBody, .reactionBody): return {
        guard case .reactionBody(let l) = lhs, case .reactionBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.verificationAddEthAddressBody, .verificationAddEthAddressBody): return {
        guard case .verificationAddEthAddressBody(let l) = lhs, case .verificationAddEthAddressBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.verificationRemoveBody, .verificationRemoveBody): return {
        guard case .verificationRemoveBody(let l) = lhs, case .verificationRemoveBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.signerAddBody, .signerAddBody): return {
        guard case .signerAddBody(let l) = lhs, case .signerAddBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userDataBody, .userDataBody): return {
        guard case .userDataBody(let l) = lhs, case .userDataBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.signerRemoveBody, .signerRemoveBody): return {
        guard case .signerRemoveBody(let l) = lhs, case .signerRemoveBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.linkBody, .linkBody): return {
        guard case .linkBody(let l) = lhs, case .linkBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///* Adds an Ed25519 key pair that signs messages for a user 
public struct SignerAddBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Public key of the Ed25519 key pair
  public var signer: Data = Data()

  /// Name of the key pair
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
}

///* Removes an Ed25519 key pair that signs messages for a user 
public struct SignerRemoveBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Public key of the Ed25519 key pair
  public var signer: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///* Adds metadata about a user 
public struct UserDataBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of metadata
  public var type: UserDataType = .none

  /// Value of the metadata
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Embed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var embed: Embed.OneOf_Embed? = nil

  public var url: String {
    get {
      if case .url(let v)? = embed {return v}
      return String()
    }
    set {embed = .url(newValue)}
  }

  public var castID: CastId {
    get {
      if case .castID(let v)? = embed {return v}
      return CastId()
    }
    set {embed = .castID(newValue)}
  }

  public var fid: UInt64 {
    get {
      if case .fid(let v)? = embed {return v}
      return 0
    }
    set {embed = .fid(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Embed: Equatable {
    case url(String)
    case castID(CastId)
    case fid(UInt64)

  #if !swift(>=4.1)
    public static func ==(lhs: Embed.OneOf_Embed, rhs: Embed.OneOf_Embed) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.url, .url): return {
        guard case .url(let l) = lhs, case .url(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.castID, .castID): return {
        guard case .castID(let l) = lhs, case .castID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fid, .fid): return {
        guard case .fid(let l) = lhs, case .fid(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///* Adds a new Cast 
public struct CastAddBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// URLs to be embedded in the cast
  public var embedsDeprecated: [String] = []

  /// Fids mentioned in the cast
  public var mentions: [UInt64] = []

  public var parent: CastAddBody.OneOf_Parent? = nil

  /// Parent cast of the cast
  public var parentCastID: CastId {
    get {
      if case .parentCastID(let v)? = parent {return v}
      return CastId()
    }
    set {parent = .parentCastID(newValue)}
  }

  /// Parent URL
  public var parentURL: String {
    get {
      if case .parentURL(let v)? = parent {return v}
      return String()
    }
    set {parent = .parentURL(newValue)}
  }

  /// Text of the cast
  public var text: String = String()

  /// Positions of the mentions in the text
  public var mentionsPositions: [UInt32] = []

  /// URLs or cast ids to be embedded in the cast
  public var embeds: [Embed] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Parent: Equatable {
    /// Parent cast of the cast
    case parentCastID(CastId)
    /// Parent URL
    case parentURL(String)

  #if !swift(>=4.1)
    public static func ==(lhs: CastAddBody.OneOf_Parent, rhs: CastAddBody.OneOf_Parent) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.parentCastID, .parentCastID): return {
        guard case .parentCastID(let l) = lhs, case .parentCastID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.parentURL, .parentURL): return {
        guard case .parentURL(let l) = lhs, case .parentURL(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///* Removes an existing Cast 
public struct CastRemoveBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hash of the cast to remove
  public var targetHash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///* Identifier used to look up a Cast 
public struct CastId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Fid of the user who created the cast
  public var fid: UInt64 = 0

  /// Hash of the cast
  public var hash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///* Adds or removes a Reaction from a Cast 
public struct ReactionBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of reaction
  public var type: ReactionType = .none

  public var target: ReactionBody.OneOf_Target? = nil

  /// CastId of the Cast to react to
  public var targetCastID: CastId {
    get {
      if case .targetCastID(let v)? = target {return v}
      return CastId()
    }
    set {target = .targetCastID(newValue)}
  }

  /// URL to react to
  public var targetURL: String {
    get {
      if case .targetURL(let v)? = target {return v}
      return String()
    }
    set {target = .targetURL(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Target: Equatable {
    /// CastId of the Cast to react to
    case targetCastID(CastId)
    /// URL to react to
    case targetURL(String)

  #if !swift(>=4.1)
    public static func ==(lhs: ReactionBody.OneOf_Target, rhs: ReactionBody.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.targetCastID, .targetCastID): return {
        guard case .targetCastID(let l) = lhs, case .targetCastID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.targetURL, .targetURL): return {
        guard case .targetURL(let l) = lhs, case .targetURL(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///* Adds a Verification of ownership of an Ethereum Address 
public struct VerificationAddEthAddressBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ethereum address being verified
  public var address: Data = Data()

  /// Signature produced by the user's Ethereum address
  public var ethSignature: Data = Data()

  /// Hash of the latest Ethereum block when the signature was produced
  public var blockHash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///* Removes a Verification of any type 
public struct VerificationRemoveBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Address of the Verification to remove
  public var address: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///* Adds or removes a Link 
public struct LinkBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of link, <= 8 characters
  public var type: String = String()

  /// User-defined timestamp that preserves original timestamp when message.data.timestamp needs to be updated for compaction
  public var displayTimestamp: UInt32 {
    get {return _displayTimestamp ?? 0}
    set {_displayTimestamp = newValue}
  }
  /// Returns true if `displayTimestamp` has been explicitly set.
  public var hasDisplayTimestamp: Bool {return self._displayTimestamp != nil}
  /// Clears the value of `displayTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearDisplayTimestamp() {self._displayTimestamp = nil}

  public var target: LinkBody.OneOf_Target? = nil

  /// The fid the link relates to
  public var targetFid: UInt64 {
    get {
      if case .targetFid(let v)? = target {return v}
      return 0
    }
    set {target = .targetFid(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Target: Equatable {
    /// The fid the link relates to
    case targetFid(UInt64)

  #if !swift(>=4.1)
    public static func ==(lhs: LinkBody.OneOf_Target, rhs: LinkBody.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.targetFid, .targetFid): return {
        guard case .targetFid(let l) = lhs, case .targetFid(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _displayTimestamp: UInt32? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension HashScheme: @unchecked Sendable {}
extension SignatureScheme: @unchecked Sendable {}
extension MessageType: @unchecked Sendable {}
extension FarcasterNetwork: @unchecked Sendable {}
extension UserDataType: @unchecked Sendable {}
extension ReactionType: @unchecked Sendable {}
extension Message: @unchecked Sendable {}
extension MessageData: @unchecked Sendable {}
extension MessageData.OneOf_Body: @unchecked Sendable {}
extension SignerAddBody: @unchecked Sendable {}
extension SignerRemoveBody: @unchecked Sendable {}
extension UserDataBody: @unchecked Sendable {}
extension Embed: @unchecked Sendable {}
extension Embed.OneOf_Embed: @unchecked Sendable {}
extension CastAddBody: @unchecked Sendable {}
extension CastAddBody.OneOf_Parent: @unchecked Sendable {}
extension CastRemoveBody: @unchecked Sendable {}
extension CastId: @unchecked Sendable {}
extension ReactionBody: @unchecked Sendable {}
extension ReactionBody.OneOf_Target: @unchecked Sendable {}
extension VerificationAddEthAddressBody: @unchecked Sendable {}
extension VerificationRemoveBody: @unchecked Sendable {}
extension LinkBody: @unchecked Sendable {}
extension LinkBody.OneOf_Target: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension HashScheme: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HASH_SCHEME_NONE"),
    1: .same(proto: "HASH_SCHEME_BLAKE3"),
  ]
}

extension SignatureScheme: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SIGNATURE_SCHEME_NONE"),
    1: .same(proto: "SIGNATURE_SCHEME_ED25519"),
    2: .same(proto: "SIGNATURE_SCHEME_EIP712"),
  ]
}

extension MessageType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MESSAGE_TYPE_NONE"),
    1: .same(proto: "MESSAGE_TYPE_CAST_ADD"),
    2: .same(proto: "MESSAGE_TYPE_CAST_REMOVE"),
    3: .same(proto: "MESSAGE_TYPE_REACTION_ADD"),
    4: .same(proto: "MESSAGE_TYPE_REACTION_REMOVE"),
    5: .same(proto: "MESSAGE_TYPE_LINK_ADD"),
    6: .same(proto: "MESSAGE_TYPE_LINK_REMOVE"),
    7: .same(proto: "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS"),
    8: .same(proto: "MESSAGE_TYPE_VERIFICATION_REMOVE"),
    9: .same(proto: "MESSAGE_TYPE_SIGNER_ADD"),
    10: .same(proto: "MESSAGE_TYPE_SIGNER_REMOVE"),
    11: .same(proto: "MESSAGE_TYPE_USER_DATA_ADD"),
  ]
}

extension FarcasterNetwork: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FARCASTER_NETWORK_NONE"),
    1: .same(proto: "FARCASTER_NETWORK_MAINNET"),
    2: .same(proto: "FARCASTER_NETWORK_TESTNET"),
    3: .same(proto: "FARCASTER_NETWORK_DEVNET"),
  ]
}

extension UserDataType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USER_DATA_TYPE_NONE"),
    1: .same(proto: "USER_DATA_TYPE_PFP"),
    2: .same(proto: "USER_DATA_TYPE_DISPLAY"),
    3: .same(proto: "USER_DATA_TYPE_BIO"),
    5: .same(proto: "USER_DATA_TYPE_URL"),
    6: .same(proto: "USER_DATA_TYPE_FNAME"),
  ]
}

extension ReactionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REACTION_TYPE_NONE"),
    1: .same(proto: "REACTION_TYPE_LIKE"),
    2: .same(proto: "REACTION_TYPE_RECAST"),
  ]
}

extension Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "hash"),
    3: .standard(proto: "hash_scheme"),
    4: .same(proto: "signature"),
    5: .standard(proto: "signature_scheme"),
    6: .same(proto: "signer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.hashScheme) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.signatureScheme) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.signer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 2)
    }
    if self.hashScheme != .none {
      try visitor.visitSingularEnumField(value: self.hashScheme, fieldNumber: 3)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 4)
    }
    if self.signatureScheme != .none {
      try visitor.visitSingularEnumField(value: self.signatureScheme, fieldNumber: 5)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularBytesField(value: self.signer, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Message, rhs: Message) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.hashScheme != rhs.hashScheme {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.signatureScheme != rhs.signatureScheme {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "fid"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "network"),
    5: .standard(proto: "cast_add_body"),
    6: .standard(proto: "cast_remove_body"),
    7: .standard(proto: "reaction_body"),
    9: .standard(proto: "verification_add_eth_address_body"),
    10: .standard(proto: "verification_remove_body"),
    11: .standard(proto: "signer_add_body"),
    12: .standard(proto: "user_data_body"),
    13: .standard(proto: "signer_remove_body"),
    14: .standard(proto: "link_body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.fid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.network) }()
      case 5: try {
        var v: CastAddBody?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .castAddBody(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .castAddBody(v)
        }
      }()
      case 6: try {
        var v: CastRemoveBody?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .castRemoveBody(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .castRemoveBody(v)
        }
      }()
      case 7: try {
        var v: ReactionBody?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .reactionBody(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .reactionBody(v)
        }
      }()
      case 9: try {
        var v: VerificationAddEthAddressBody?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .verificationAddEthAddressBody(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .verificationAddEthAddressBody(v)
        }
      }()
      case 10: try {
        var v: VerificationRemoveBody?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .verificationRemoveBody(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .verificationRemoveBody(v)
        }
      }()
      case 11: try {
        var v: SignerAddBody?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .signerAddBody(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .signerAddBody(v)
        }
      }()
      case 12: try {
        var v: UserDataBody?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userDataBody(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userDataBody(v)
        }
      }()
      case 13: try {
        var v: SignerRemoveBody?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .signerRemoveBody(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .signerRemoveBody(v)
        }
      }()
      case 14: try {
        var v: LinkBody?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .linkBody(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .linkBody(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .none {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.fid != 0 {
      try visitor.visitSingularUInt64Field(value: self.fid, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 3)
    }
    if self.network != .none {
      try visitor.visitSingularEnumField(value: self.network, fieldNumber: 4)
    }
    switch self.body {
    case .castAddBody?: try {
      guard case .castAddBody(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .castRemoveBody?: try {
      guard case .castRemoveBody(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .reactionBody?: try {
      guard case .reactionBody(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .verificationAddEthAddressBody?: try {
      guard case .verificationAddEthAddressBody(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .verificationRemoveBody?: try {
      guard case .verificationRemoveBody(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .signerAddBody?: try {
      guard case .signerAddBody(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .userDataBody?: try {
      guard case .userDataBody(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .signerRemoveBody?: try {
      guard case .signerRemoveBody(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .linkBody?: try {
      guard case .linkBody(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageData, rhs: MessageData) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.fid != rhs.fid {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.network != rhs.network {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignerAddBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SignerAddBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signer"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.signer.isEmpty {
      try visitor.visitSingularBytesField(value: self.signer, fieldNumber: 1)
    }
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SignerAddBody, rhs: SignerAddBody) -> Bool {
    if lhs.signer != rhs.signer {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignerRemoveBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SignerRemoveBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signer.isEmpty {
      try visitor.visitSingularBytesField(value: self.signer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SignerRemoveBody, rhs: SignerRemoveBody) -> Bool {
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserDataBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserDataBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .none {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserDataBody, rhs: UserDataBody) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Embed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Embed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .standard(proto: "cast_id"),
    3: .same(proto: "fid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.embed != nil {try decoder.handleConflictingOneOf()}
          self.embed = .url(v)
        }
      }()
      case 2: try {
        var v: CastId?
        var hadOneofValue = false
        if let current = self.embed {
          hadOneofValue = true
          if case .castID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.embed = .castID(v)
        }
      }()
      case 3: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.embed != nil {try decoder.handleConflictingOneOf()}
          self.embed = .fid(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.embed {
    case .url?: try {
      guard case .url(let v)? = self.embed else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .castID?: try {
      guard case .castID(let v)? = self.embed else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .fid?: try {
      guard case .fid(let v)? = self.embed else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Embed, rhs: Embed) -> Bool {
    if lhs.embed != rhs.embed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CastAddBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CastAddBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "embeds_deprecated"),
    2: .same(proto: "mentions"),
    3: .standard(proto: "parent_cast_id"),
    7: .standard(proto: "parent_url"),
    4: .same(proto: "text"),
    5: .standard(proto: "mentions_positions"),
    6: .same(proto: "embeds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.embedsDeprecated) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.mentions) }()
      case 3: try {
        var v: CastId?
        var hadOneofValue = false
        if let current = self.parent {
          hadOneofValue = true
          if case .parentCastID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parent = .parentCastID(v)
        }
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 5: try { try decoder.decodeRepeatedUInt32Field(value: &self.mentionsPositions) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.embeds) }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.parent != nil {try decoder.handleConflictingOneOf()}
          self.parent = .parentURL(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.embedsDeprecated.isEmpty {
      try visitor.visitRepeatedStringField(value: self.embedsDeprecated, fieldNumber: 1)
    }
    if !self.mentions.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.mentions, fieldNumber: 2)
    }
    try { if case .parentCastID(let v)? = self.parent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 4)
    }
    if !self.mentionsPositions.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.mentionsPositions, fieldNumber: 5)
    }
    if !self.embeds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.embeds, fieldNumber: 6)
    }
    try { if case .parentURL(let v)? = self.parent {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CastAddBody, rhs: CastAddBody) -> Bool {
    if lhs.embedsDeprecated != rhs.embedsDeprecated {return false}
    if lhs.mentions != rhs.mentions {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.text != rhs.text {return false}
    if lhs.mentionsPositions != rhs.mentionsPositions {return false}
    if lhs.embeds != rhs.embeds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CastRemoveBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CastRemoveBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.targetHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.targetHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CastRemoveBody, rhs: CastRemoveBody) -> Bool {
    if lhs.targetHash != rhs.targetHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CastId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CastId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fid"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.fid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fid != 0 {
      try visitor.visitSingularUInt64Field(value: self.fid, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CastId, rhs: CastId) -> Bool {
    if lhs.fid != rhs.fid {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ReactionBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "target_cast_id"),
    3: .standard(proto: "target_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: CastId?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .targetCastID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .targetCastID(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .targetURL(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .none {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.target {
    case .targetCastID?: try {
      guard case .targetCastID(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .targetURL?: try {
      guard case .targetURL(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReactionBody, rhs: ReactionBody) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VerificationAddEthAddressBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "VerificationAddEthAddressBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "eth_signature"),
    3: .standard(proto: "block_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.ethSignature) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.blockHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if !self.ethSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.ethSignature, fieldNumber: 2)
    }
    if !self.blockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockHash, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VerificationAddEthAddressBody, rhs: VerificationAddEthAddressBody) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.ethSignature != rhs.ethSignature {return false}
    if lhs.blockHash != rhs.blockHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VerificationRemoveBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "VerificationRemoveBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VerificationRemoveBody, rhs: VerificationRemoveBody) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LinkBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LinkBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "displayTimestamp"),
    3: .standard(proto: "target_fid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._displayTimestamp) }()
      case 3: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .targetFid(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._displayTimestamp {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if case .targetFid(let v)? = self.target {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LinkBody, rhs: LinkBody) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._displayTimestamp != rhs._displayTimestamp {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
