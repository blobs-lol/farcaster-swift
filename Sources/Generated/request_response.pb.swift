// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: request_response.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SubscribeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventTypes: [HubEventType] = []

  public var fromID: UInt64 {
    get {return _fromID ?? 0}
    set {_fromID = newValue}
  }
  /// Returns true if `fromID` has been explicitly set.
  public var hasFromID: Bool {return self._fromID != nil}
  /// Clears the value of `fromID`. Subsequent reads from it will return its default value.
  public mutating func clearFromID() {self._fromID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fromID: UInt64? = nil
}

public struct EventRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct HubInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dbStats: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response Types for the Sync RPC Methods
public struct HubInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: String = String()

  public var isSyncing: Bool = false

  public var nickname: String = String()

  public var rootHash: String = String()

  public var dbStats: DbStats {
    get {return _dbStats ?? DbStats()}
    set {_dbStats = newValue}
  }
  /// Returns true if `dbStats` has been explicitly set.
  public var hasDbStats: Bool {return self._dbStats != nil}
  /// Clears the value of `dbStats`. Subsequent reads from it will return its default value.
  public mutating func clearDbStats() {self._dbStats = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dbStats: DbStats? = nil
}

public struct DbStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var numMessages: UInt64 = 0

  public var numFidEvents: UInt64 = 0

  public var numFnameEvents: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SyncStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var peerID: String {
    get {return _peerID ?? String()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: String? = nil
}

public struct SyncStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isSyncing: Bool = false

  public var syncStatus: [SyncStatus] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SyncStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var peerID: String = String()

  public var inSync: String = String()

  public var shouldSync: Bool = false

  public var divergencePrefix: String = String()

  public var divergenceSecondsAgo: Int32 = 0

  public var theirMessages: UInt64 = 0

  public var ourMessages: UInt64 = 0

  public var lastBadSync: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TrieNodeMetadataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var prefix: Data = Data()

  public var numMessages: UInt64 = 0

  public var hash: String = String()

  public var children: [TrieNodeMetadataResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TrieNodeSnapshotResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var prefix: Data = Data()

  public var excludedHashes: [String] = []

  public var numMessages: UInt64 = 0

  public var rootHash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TrieNodePrefix {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var prefix: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SyncIds {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var syncIds: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FidRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fid: UInt64 = 0

  public var pageSize: UInt32 {
    get {return _pageSize ?? 0}
    set {_pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  public var hasPageSize: Bool {return self._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  public mutating func clearPageSize() {self._pageSize = nil}

  public var pageToken: Data {
    get {return _pageToken ?? Data()}
    set {_pageToken = newValue}
  }
  /// Returns true if `pageToken` has been explicitly set.
  public var hasPageToken: Bool {return self._pageToken != nil}
  /// Clears the value of `pageToken`. Subsequent reads from it will return its default value.
  public mutating func clearPageToken() {self._pageToken = nil}

  public var reverse: Bool {
    get {return _reverse ?? false}
    set {_reverse = newValue}
  }
  /// Returns true if `reverse` has been explicitly set.
  public var hasReverse: Bool {return self._reverse != nil}
  /// Clears the value of `reverse`. Subsequent reads from it will return its default value.
  public mutating func clearReverse() {self._reverse = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pageSize: UInt32? = nil
  fileprivate var _pageToken: Data? = nil
  fileprivate var _reverse: Bool? = nil
}

public struct FidsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pageSize: UInt32 {
    get {return _pageSize ?? 0}
    set {_pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  public var hasPageSize: Bool {return self._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  public mutating func clearPageSize() {self._pageSize = nil}

  public var pageToken: Data {
    get {return _pageToken ?? Data()}
    set {_pageToken = newValue}
  }
  /// Returns true if `pageToken` has been explicitly set.
  public var hasPageToken: Bool {return self._pageToken != nil}
  /// Clears the value of `pageToken`. Subsequent reads from it will return its default value.
  public mutating func clearPageToken() {self._pageToken = nil}

  public var reverse: Bool {
    get {return _reverse ?? false}
    set {_reverse = newValue}
  }
  /// Returns true if `reverse` has been explicitly set.
  public var hasReverse: Bool {return self._reverse != nil}
  /// Clears the value of `reverse`. Subsequent reads from it will return its default value.
  public mutating func clearReverse() {self._reverse = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pageSize: UInt32? = nil
  fileprivate var _pageToken: Data? = nil
  fileprivate var _reverse: Bool? = nil
}

public struct FidsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fids: [UInt64] = []

  public var nextPageToken: Data {
    get {return _nextPageToken ?? Data()}
    set {_nextPageToken = newValue}
  }
  /// Returns true if `nextPageToken` has been explicitly set.
  public var hasNextPageToken: Bool {return self._nextPageToken != nil}
  /// Clears the value of `nextPageToken`. Subsequent reads from it will return its default value.
  public mutating func clearNextPageToken() {self._nextPageToken = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nextPageToken: Data? = nil
}

public struct MessagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Message] = []

  public var nextPageToken: Data {
    get {return _nextPageToken ?? Data()}
    set {_nextPageToken = newValue}
  }
  /// Returns true if `nextPageToken` has been explicitly set.
  public var hasNextPageToken: Bool {return self._nextPageToken != nil}
  /// Clears the value of `nextPageToken`. Subsequent reads from it will return its default value.
  public mutating func clearNextPageToken() {self._nextPageToken = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nextPageToken: Data? = nil
}

public struct CastsByParentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parent: CastsByParentRequest.OneOf_Parent? = nil

  public var parentCastID: CastId {
    get {
      if case .parentCastID(let v)? = parent {return v}
      return CastId()
    }
    set {parent = .parentCastID(newValue)}
  }

  public var parentURL: String {
    get {
      if case .parentURL(let v)? = parent {return v}
      return String()
    }
    set {parent = .parentURL(newValue)}
  }

  public var pageSize: UInt32 {
    get {return _pageSize ?? 0}
    set {_pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  public var hasPageSize: Bool {return self._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  public mutating func clearPageSize() {self._pageSize = nil}

  public var pageToken: Data {
    get {return _pageToken ?? Data()}
    set {_pageToken = newValue}
  }
  /// Returns true if `pageToken` has been explicitly set.
  public var hasPageToken: Bool {return self._pageToken != nil}
  /// Clears the value of `pageToken`. Subsequent reads from it will return its default value.
  public mutating func clearPageToken() {self._pageToken = nil}

  public var reverse: Bool {
    get {return _reverse ?? false}
    set {_reverse = newValue}
  }
  /// Returns true if `reverse` has been explicitly set.
  public var hasReverse: Bool {return self._reverse != nil}
  /// Clears the value of `reverse`. Subsequent reads from it will return its default value.
  public mutating func clearReverse() {self._reverse = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Parent: Equatable {
    case parentCastID(CastId)
    case parentURL(String)

  #if !swift(>=4.1)
    public static func ==(lhs: CastsByParentRequest.OneOf_Parent, rhs: CastsByParentRequest.OneOf_Parent) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.parentCastID, .parentCastID): return {
        guard case .parentCastID(let l) = lhs, case .parentCastID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.parentURL, .parentURL): return {
        guard case .parentURL(let l) = lhs, case .parentURL(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _pageSize: UInt32? = nil
  fileprivate var _pageToken: Data? = nil
  fileprivate var _reverse: Bool? = nil
}

public struct ReactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fid: UInt64 = 0

  public var reactionType: ReactionType = .none

  public var target: ReactionRequest.OneOf_Target? = nil

  public var targetCastID: CastId {
    get {
      if case .targetCastID(let v)? = target {return v}
      return CastId()
    }
    set {target = .targetCastID(newValue)}
  }

  public var targetURL: String {
    get {
      if case .targetURL(let v)? = target {return v}
      return String()
    }
    set {target = .targetURL(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Target: Equatable {
    case targetCastID(CastId)
    case targetURL(String)

  #if !swift(>=4.1)
    public static func ==(lhs: ReactionRequest.OneOf_Target, rhs: ReactionRequest.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.targetCastID, .targetCastID): return {
        guard case .targetCastID(let l) = lhs, case .targetCastID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.targetURL, .targetURL): return {
        guard case .targetURL(let l) = lhs, case .targetURL(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct ReactionsByFidRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fid: UInt64 = 0

  public var reactionType: ReactionType {
    get {return _reactionType ?? .none}
    set {_reactionType = newValue}
  }
  /// Returns true if `reactionType` has been explicitly set.
  public var hasReactionType: Bool {return self._reactionType != nil}
  /// Clears the value of `reactionType`. Subsequent reads from it will return its default value.
  public mutating func clearReactionType() {self._reactionType = nil}

  public var pageSize: UInt32 {
    get {return _pageSize ?? 0}
    set {_pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  public var hasPageSize: Bool {return self._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  public mutating func clearPageSize() {self._pageSize = nil}

  public var pageToken: Data {
    get {return _pageToken ?? Data()}
    set {_pageToken = newValue}
  }
  /// Returns true if `pageToken` has been explicitly set.
  public var hasPageToken: Bool {return self._pageToken != nil}
  /// Clears the value of `pageToken`. Subsequent reads from it will return its default value.
  public mutating func clearPageToken() {self._pageToken = nil}

  public var reverse: Bool {
    get {return _reverse ?? false}
    set {_reverse = newValue}
  }
  /// Returns true if `reverse` has been explicitly set.
  public var hasReverse: Bool {return self._reverse != nil}
  /// Clears the value of `reverse`. Subsequent reads from it will return its default value.
  public mutating func clearReverse() {self._reverse = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _reactionType: ReactionType? = nil
  fileprivate var _pageSize: UInt32? = nil
  fileprivate var _pageToken: Data? = nil
  fileprivate var _reverse: Bool? = nil
}

public struct ReactionsByTargetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var target: ReactionsByTargetRequest.OneOf_Target? = nil

  public var targetCastID: CastId {
    get {
      if case .targetCastID(let v)? = target {return v}
      return CastId()
    }
    set {target = .targetCastID(newValue)}
  }

  public var targetURL: String {
    get {
      if case .targetURL(let v)? = target {return v}
      return String()
    }
    set {target = .targetURL(newValue)}
  }

  public var reactionType: ReactionType {
    get {return _reactionType ?? .none}
    set {_reactionType = newValue}
  }
  /// Returns true if `reactionType` has been explicitly set.
  public var hasReactionType: Bool {return self._reactionType != nil}
  /// Clears the value of `reactionType`. Subsequent reads from it will return its default value.
  public mutating func clearReactionType() {self._reactionType = nil}

  public var pageSize: UInt32 {
    get {return _pageSize ?? 0}
    set {_pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  public var hasPageSize: Bool {return self._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  public mutating func clearPageSize() {self._pageSize = nil}

  public var pageToken: Data {
    get {return _pageToken ?? Data()}
    set {_pageToken = newValue}
  }
  /// Returns true if `pageToken` has been explicitly set.
  public var hasPageToken: Bool {return self._pageToken != nil}
  /// Clears the value of `pageToken`. Subsequent reads from it will return its default value.
  public mutating func clearPageToken() {self._pageToken = nil}

  public var reverse: Bool {
    get {return _reverse ?? false}
    set {_reverse = newValue}
  }
  /// Returns true if `reverse` has been explicitly set.
  public var hasReverse: Bool {return self._reverse != nil}
  /// Clears the value of `reverse`. Subsequent reads from it will return its default value.
  public mutating func clearReverse() {self._reverse = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Target: Equatable {
    case targetCastID(CastId)
    case targetURL(String)

  #if !swift(>=4.1)
    public static func ==(lhs: ReactionsByTargetRequest.OneOf_Target, rhs: ReactionsByTargetRequest.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.targetCastID, .targetCastID): return {
        guard case .targetCastID(let l) = lhs, case .targetCastID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.targetURL, .targetURL): return {
        guard case .targetURL(let l) = lhs, case .targetURL(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _reactionType: ReactionType? = nil
  fileprivate var _pageSize: UInt32? = nil
  fileprivate var _pageToken: Data? = nil
  fileprivate var _reverse: Bool? = nil
}

public struct UserDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fid: UInt64 = 0

  public var userDataType: UserDataType = .none

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct NameRegistryEventRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct VerificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fid: UInt64 = 0

  public var address: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SignerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fid: UInt64 = 0

  public var signer: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct LinkRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fid: UInt64 = 0

  public var linkType: String = String()

  public var target: LinkRequest.OneOf_Target? = nil

  public var targetFid: UInt64 {
    get {
      if case .targetFid(let v)? = target {return v}
      return 0
    }
    set {target = .targetFid(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Target: Equatable {
    case targetFid(UInt64)

  #if !swift(>=4.1)
    public static func ==(lhs: LinkRequest.OneOf_Target, rhs: LinkRequest.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.targetFid, .targetFid): return {
        guard case .targetFid(let l) = lhs, case .targetFid(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

public struct LinksByFidRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fid: UInt64 = 0

  public var linkType: String {
    get {return _linkType ?? String()}
    set {_linkType = newValue}
  }
  /// Returns true if `linkType` has been explicitly set.
  public var hasLinkType: Bool {return self._linkType != nil}
  /// Clears the value of `linkType`. Subsequent reads from it will return its default value.
  public mutating func clearLinkType() {self._linkType = nil}

  public var pageSize: UInt32 {
    get {return _pageSize ?? 0}
    set {_pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  public var hasPageSize: Bool {return self._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  public mutating func clearPageSize() {self._pageSize = nil}

  public var pageToken: Data {
    get {return _pageToken ?? Data()}
    set {_pageToken = newValue}
  }
  /// Returns true if `pageToken` has been explicitly set.
  public var hasPageToken: Bool {return self._pageToken != nil}
  /// Clears the value of `pageToken`. Subsequent reads from it will return its default value.
  public mutating func clearPageToken() {self._pageToken = nil}

  public var reverse: Bool {
    get {return _reverse ?? false}
    set {_reverse = newValue}
  }
  /// Returns true if `reverse` has been explicitly set.
  public var hasReverse: Bool {return self._reverse != nil}
  /// Clears the value of `reverse`. Subsequent reads from it will return its default value.
  public mutating func clearReverse() {self._reverse = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _linkType: String? = nil
  fileprivate var _pageSize: UInt32? = nil
  fileprivate var _pageToken: Data? = nil
  fileprivate var _reverse: Bool? = nil
}

public struct LinksByTargetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var target: LinksByTargetRequest.OneOf_Target? = nil

  public var targetFid: UInt64 {
    get {
      if case .targetFid(let v)? = target {return v}
      return 0
    }
    set {target = .targetFid(newValue)}
  }

  public var linkType: String {
    get {return _linkType ?? String()}
    set {_linkType = newValue}
  }
  /// Returns true if `linkType` has been explicitly set.
  public var hasLinkType: Bool {return self._linkType != nil}
  /// Clears the value of `linkType`. Subsequent reads from it will return its default value.
  public mutating func clearLinkType() {self._linkType = nil}

  public var pageSize: UInt32 {
    get {return _pageSize ?? 0}
    set {_pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  public var hasPageSize: Bool {return self._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  public mutating func clearPageSize() {self._pageSize = nil}

  public var pageToken: Data {
    get {return _pageToken ?? Data()}
    set {_pageToken = newValue}
  }
  /// Returns true if `pageToken` has been explicitly set.
  public var hasPageToken: Bool {return self._pageToken != nil}
  /// Clears the value of `pageToken`. Subsequent reads from it will return its default value.
  public mutating func clearPageToken() {self._pageToken = nil}

  public var reverse: Bool {
    get {return _reverse ?? false}
    set {_reverse = newValue}
  }
  /// Returns true if `reverse` has been explicitly set.
  public var hasReverse: Bool {return self._reverse != nil}
  /// Clears the value of `reverse`. Subsequent reads from it will return its default value.
  public mutating func clearReverse() {self._reverse = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Target: Equatable {
    case targetFid(UInt64)

  #if !swift(>=4.1)
    public static func ==(lhs: LinksByTargetRequest.OneOf_Target, rhs: LinksByTargetRequest.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.targetFid, .targetFid): return {
        guard case .targetFid(let l) = lhs, case .targetFid(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _linkType: String? = nil
  fileprivate var _pageSize: UInt32? = nil
  fileprivate var _pageToken: Data? = nil
  fileprivate var _reverse: Bool? = nil
}

public struct IdRegistryEventRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fid: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IdRegistryEventByAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Empty: @unchecked Sendable {}
extension SubscribeRequest: @unchecked Sendable {}
extension EventRequest: @unchecked Sendable {}
extension HubInfoRequest: @unchecked Sendable {}
extension HubInfoResponse: @unchecked Sendable {}
extension DbStats: @unchecked Sendable {}
extension SyncStatusRequest: @unchecked Sendable {}
extension SyncStatusResponse: @unchecked Sendable {}
extension SyncStatus: @unchecked Sendable {}
extension TrieNodeMetadataResponse: @unchecked Sendable {}
extension TrieNodeSnapshotResponse: @unchecked Sendable {}
extension TrieNodePrefix: @unchecked Sendable {}
extension SyncIds: @unchecked Sendable {}
extension FidRequest: @unchecked Sendable {}
extension FidsRequest: @unchecked Sendable {}
extension FidsResponse: @unchecked Sendable {}
extension MessagesResponse: @unchecked Sendable {}
extension CastsByParentRequest: @unchecked Sendable {}
extension CastsByParentRequest.OneOf_Parent: @unchecked Sendable {}
extension ReactionRequest: @unchecked Sendable {}
extension ReactionRequest.OneOf_Target: @unchecked Sendable {}
extension ReactionsByFidRequest: @unchecked Sendable {}
extension ReactionsByTargetRequest: @unchecked Sendable {}
extension ReactionsByTargetRequest.OneOf_Target: @unchecked Sendable {}
extension UserDataRequest: @unchecked Sendable {}
extension NameRegistryEventRequest: @unchecked Sendable {}
extension VerificationRequest: @unchecked Sendable {}
extension SignerRequest: @unchecked Sendable {}
extension LinkRequest: @unchecked Sendable {}
extension LinkRequest.OneOf_Target: @unchecked Sendable {}
extension LinksByFidRequest: @unchecked Sendable {}
extension LinksByTargetRequest: @unchecked Sendable {}
extension LinksByTargetRequest.OneOf_Target: @unchecked Sendable {}
extension IdRegistryEventRequest: @unchecked Sendable {}
extension IdRegistryEventByAddressRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Empty"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Empty, rhs: Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SubscribeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_types"),
    2: .standard(proto: "from_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.eventTypes) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._fromID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.eventTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.eventTypes, fieldNumber: 1)
    }
    try { if let v = self._fromID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeRequest, rhs: SubscribeRequest) -> Bool {
    if lhs.eventTypes != rhs.eventTypes {return false}
    if lhs._fromID != rhs._fromID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EventRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventRequest, rhs: EventRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HubInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "HubInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "db_stats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.dbStats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dbStats != false {
      try visitor.visitSingularBoolField(value: self.dbStats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HubInfoRequest, rhs: HubInfoRequest) -> Bool {
    if lhs.dbStats != rhs.dbStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HubInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "HubInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "is_syncing"),
    3: .same(proto: "nickname"),
    4: .standard(proto: "root_hash"),
    5: .standard(proto: "db_stats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isSyncing) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.rootHash) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._dbStats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if self.isSyncing != false {
      try visitor.visitSingularBoolField(value: self.isSyncing, fieldNumber: 2)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 3)
    }
    if !self.rootHash.isEmpty {
      try visitor.visitSingularStringField(value: self.rootHash, fieldNumber: 4)
    }
    try { if let v = self._dbStats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HubInfoResponse, rhs: HubInfoResponse) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.isSyncing != rhs.isSyncing {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.rootHash != rhs.rootHash {return false}
    if lhs._dbStats != rhs._dbStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DbStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DbStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_messages"),
    2: .standard(proto: "num_fid_events"),
    3: .standard(proto: "num_fname_events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.numMessages) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.numFidEvents) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.numFnameEvents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numMessages != 0 {
      try visitor.visitSingularUInt64Field(value: self.numMessages, fieldNumber: 1)
    }
    if self.numFidEvents != 0 {
      try visitor.visitSingularUInt64Field(value: self.numFidEvents, fieldNumber: 2)
    }
    if self.numFnameEvents != 0 {
      try visitor.visitSingularUInt64Field(value: self.numFnameEvents, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DbStats, rhs: DbStats) -> Bool {
    if lhs.numMessages != rhs.numMessages {return false}
    if lhs.numFidEvents != rhs.numFidEvents {return false}
    if lhs.numFnameEvents != rhs.numFnameEvents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SyncStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SyncStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peerId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._peerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SyncStatusRequest, rhs: SyncStatusRequest) -> Bool {
    if lhs._peerID != rhs._peerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SyncStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SyncStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_syncing"),
    2: .standard(proto: "sync_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isSyncing) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.syncStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isSyncing != false {
      try visitor.visitSingularBoolField(value: self.isSyncing, fieldNumber: 1)
    }
    if !self.syncStatus.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.syncStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SyncStatusResponse, rhs: SyncStatusResponse) -> Bool {
    if lhs.isSyncing != rhs.isSyncing {return false}
    if lhs.syncStatus != rhs.syncStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SyncStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SyncStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peerId"),
    2: .same(proto: "inSync"),
    3: .same(proto: "shouldSync"),
    4: .same(proto: "divergencePrefix"),
    5: .same(proto: "divergenceSecondsAgo"),
    6: .same(proto: "theirMessages"),
    7: .same(proto: "ourMessages"),
    8: .same(proto: "lastBadSync"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.peerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.inSync) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.shouldSync) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.divergencePrefix) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.divergenceSecondsAgo) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.theirMessages) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.ourMessages) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.lastBadSync) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peerID.isEmpty {
      try visitor.visitSingularStringField(value: self.peerID, fieldNumber: 1)
    }
    if !self.inSync.isEmpty {
      try visitor.visitSingularStringField(value: self.inSync, fieldNumber: 2)
    }
    if self.shouldSync != false {
      try visitor.visitSingularBoolField(value: self.shouldSync, fieldNumber: 3)
    }
    if !self.divergencePrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.divergencePrefix, fieldNumber: 4)
    }
    if self.divergenceSecondsAgo != 0 {
      try visitor.visitSingularInt32Field(value: self.divergenceSecondsAgo, fieldNumber: 5)
    }
    if self.theirMessages != 0 {
      try visitor.visitSingularUInt64Field(value: self.theirMessages, fieldNumber: 6)
    }
    if self.ourMessages != 0 {
      try visitor.visitSingularUInt64Field(value: self.ourMessages, fieldNumber: 7)
    }
    if self.lastBadSync != 0 {
      try visitor.visitSingularInt64Field(value: self.lastBadSync, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SyncStatus, rhs: SyncStatus) -> Bool {
    if lhs.peerID != rhs.peerID {return false}
    if lhs.inSync != rhs.inSync {return false}
    if lhs.shouldSync != rhs.shouldSync {return false}
    if lhs.divergencePrefix != rhs.divergencePrefix {return false}
    if lhs.divergenceSecondsAgo != rhs.divergenceSecondsAgo {return false}
    if lhs.theirMessages != rhs.theirMessages {return false}
    if lhs.ourMessages != rhs.ourMessages {return false}
    if lhs.lastBadSync != rhs.lastBadSync {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TrieNodeMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TrieNodeMetadataResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
    2: .standard(proto: "num_messages"),
    3: .same(proto: "hash"),
    4: .same(proto: "children"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.prefix) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.numMessages) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prefix.isEmpty {
      try visitor.visitSingularBytesField(value: self.prefix, fieldNumber: 1)
    }
    if self.numMessages != 0 {
      try visitor.visitSingularUInt64Field(value: self.numMessages, fieldNumber: 2)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 3)
    }
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TrieNodeMetadataResponse, rhs: TrieNodeMetadataResponse) -> Bool {
    if lhs.prefix != rhs.prefix {return false}
    if lhs.numMessages != rhs.numMessages {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.children != rhs.children {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TrieNodeSnapshotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TrieNodeSnapshotResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
    2: .standard(proto: "excluded_hashes"),
    3: .standard(proto: "num_messages"),
    4: .standard(proto: "root_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.prefix) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.excludedHashes) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.numMessages) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.rootHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prefix.isEmpty {
      try visitor.visitSingularBytesField(value: self.prefix, fieldNumber: 1)
    }
    if !self.excludedHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.excludedHashes, fieldNumber: 2)
    }
    if self.numMessages != 0 {
      try visitor.visitSingularUInt64Field(value: self.numMessages, fieldNumber: 3)
    }
    if !self.rootHash.isEmpty {
      try visitor.visitSingularStringField(value: self.rootHash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TrieNodeSnapshotResponse, rhs: TrieNodeSnapshotResponse) -> Bool {
    if lhs.prefix != rhs.prefix {return false}
    if lhs.excludedHashes != rhs.excludedHashes {return false}
    if lhs.numMessages != rhs.numMessages {return false}
    if lhs.rootHash != rhs.rootHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TrieNodePrefix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TrieNodePrefix"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.prefix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prefix.isEmpty {
      try visitor.visitSingularBytesField(value: self.prefix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TrieNodePrefix, rhs: TrieNodePrefix) -> Bool {
    if lhs.prefix != rhs.prefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SyncIds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SyncIds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sync_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.syncIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.syncIds.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.syncIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SyncIds, rhs: SyncIds) -> Bool {
    if lhs.syncIds != rhs.syncIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FidRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FidRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fid"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "reverse"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.fid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._pageToken) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._reverse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.fid != 0 {
      try visitor.visitSingularUInt64Field(value: self.fid, fieldNumber: 1)
    }
    try { if let v = self._pageSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pageToken {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._reverse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FidRequest, rhs: FidRequest) -> Bool {
    if lhs.fid != rhs.fid {return false}
    if lhs._pageSize != rhs._pageSize {return false}
    if lhs._pageToken != rhs._pageToken {return false}
    if lhs._reverse != rhs._reverse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FidsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FidsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "page_token"),
    3: .same(proto: "reverse"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._pageSize) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._pageToken) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._reverse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pageSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pageToken {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._reverse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FidsRequest, rhs: FidsRequest) -> Bool {
    if lhs._pageSize != rhs._pageSize {return false}
    if lhs._pageToken != rhs._pageToken {return false}
    if lhs._reverse != rhs._reverse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FidsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FidsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fids"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.fids) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fids.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.fids, fieldNumber: 1)
    }
    try { if let v = self._nextPageToken {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FidsResponse, rhs: FidsResponse) -> Bool {
    if lhs.fids != rhs.fids {return false}
    if lhs._nextPageToken != rhs._nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try { if let v = self._nextPageToken {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessagesResponse, rhs: MessagesResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs._nextPageToken != rhs._nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CastsByParentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CastsByParentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_cast_id"),
    5: .standard(proto: "parent_url"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "reverse"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CastId?
        var hadOneofValue = false
        if let current = self.parent {
          hadOneofValue = true
          if case .parentCastID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parent = .parentCastID(v)
        }
      }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._pageToken) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._reverse) }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.parent != nil {try decoder.handleConflictingOneOf()}
          self.parent = .parentURL(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .parentCastID(let v)? = self.parent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pageSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pageToken {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._reverse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if case .parentURL(let v)? = self.parent {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CastsByParentRequest, rhs: CastsByParentRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._pageSize != rhs._pageSize {return false}
    if lhs._pageToken != rhs._pageToken {return false}
    if lhs._reverse != rhs._reverse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ReactionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fid"),
    2: .standard(proto: "reaction_type"),
    3: .standard(proto: "target_cast_id"),
    4: .standard(proto: "target_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.fid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reactionType) }()
      case 3: try {
        var v: CastId?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .targetCastID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .targetCastID(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .targetURL(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.fid != 0 {
      try visitor.visitSingularUInt64Field(value: self.fid, fieldNumber: 1)
    }
    if self.reactionType != .none {
      try visitor.visitSingularEnumField(value: self.reactionType, fieldNumber: 2)
    }
    switch self.target {
    case .targetCastID?: try {
      guard case .targetCastID(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .targetURL?: try {
      guard case .targetURL(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReactionRequest, rhs: ReactionRequest) -> Bool {
    if lhs.fid != rhs.fid {return false}
    if lhs.reactionType != rhs.reactionType {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReactionsByFidRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ReactionsByFidRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fid"),
    2: .standard(proto: "reaction_type"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
    5: .same(proto: "reverse"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.fid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._reactionType) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._pageSize) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._pageToken) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._reverse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.fid != 0 {
      try visitor.visitSingularUInt64Field(value: self.fid, fieldNumber: 1)
    }
    try { if let v = self._reactionType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pageSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pageToken {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._reverse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReactionsByFidRequest, rhs: ReactionsByFidRequest) -> Bool {
    if lhs.fid != rhs.fid {return false}
    if lhs._reactionType != rhs._reactionType {return false}
    if lhs._pageSize != rhs._pageSize {return false}
    if lhs._pageToken != rhs._pageToken {return false}
    if lhs._reverse != rhs._reverse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReactionsByTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ReactionsByTargetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_cast_id"),
    6: .standard(proto: "target_url"),
    2: .standard(proto: "reaction_type"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
    5: .same(proto: "reverse"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CastId?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .targetCastID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .targetCastID(v)
        }
      }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._reactionType) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._pageSize) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._pageToken) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._reverse) }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .targetURL(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .targetCastID(let v)? = self.target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reactionType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pageSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pageToken {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._reverse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if case .targetURL(let v)? = self.target {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReactionsByTargetRequest, rhs: ReactionsByTargetRequest) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs._reactionType != rhs._reactionType {return false}
    if lhs._pageSize != rhs._pageSize {return false}
    if lhs._pageToken != rhs._pageToken {return false}
    if lhs._reverse != rhs._reverse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fid"),
    2: .standard(proto: "user_data_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.fid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.userDataType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fid != 0 {
      try visitor.visitSingularUInt64Field(value: self.fid, fieldNumber: 1)
    }
    if self.userDataType != .none {
      try visitor.visitSingularEnumField(value: self.userDataType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserDataRequest, rhs: UserDataRequest) -> Bool {
    if lhs.fid != rhs.fid {return false}
    if lhs.userDataType != rhs.userDataType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NameRegistryEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NameRegistryEventRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularBytesField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NameRegistryEventRequest, rhs: NameRegistryEventRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VerificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "VerificationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fid"),
    2: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.fid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fid != 0 {
      try visitor.visitSingularUInt64Field(value: self.fid, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VerificationRequest, rhs: VerificationRequest) -> Bool {
    if lhs.fid != rhs.fid {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SignerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fid"),
    2: .same(proto: "signer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.fid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fid != 0 {
      try visitor.visitSingularUInt64Field(value: self.fid, fieldNumber: 1)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularBytesField(value: self.signer, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SignerRequest, rhs: SignerRequest) -> Bool {
    if lhs.fid != rhs.fid {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LinkRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fid"),
    2: .standard(proto: "link_type"),
    3: .standard(proto: "target_fid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.fid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.linkType) }()
      case 3: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .targetFid(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.fid != 0 {
      try visitor.visitSingularUInt64Field(value: self.fid, fieldNumber: 1)
    }
    if !self.linkType.isEmpty {
      try visitor.visitSingularStringField(value: self.linkType, fieldNumber: 2)
    }
    try { if case .targetFid(let v)? = self.target {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LinkRequest, rhs: LinkRequest) -> Bool {
    if lhs.fid != rhs.fid {return false}
    if lhs.linkType != rhs.linkType {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LinksByFidRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LinksByFidRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fid"),
    2: .standard(proto: "link_type"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
    5: .same(proto: "reverse"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.fid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._linkType) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._pageSize) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._pageToken) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._reverse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.fid != 0 {
      try visitor.visitSingularUInt64Field(value: self.fid, fieldNumber: 1)
    }
    try { if let v = self._linkType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pageSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pageToken {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._reverse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LinksByFidRequest, rhs: LinksByFidRequest) -> Bool {
    if lhs.fid != rhs.fid {return false}
    if lhs._linkType != rhs._linkType {return false}
    if lhs._pageSize != rhs._pageSize {return false}
    if lhs._pageToken != rhs._pageToken {return false}
    if lhs._reverse != rhs._reverse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LinksByTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LinksByTargetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_fid"),
    2: .standard(proto: "link_type"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
    5: .same(proto: "reverse"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .targetFid(v)
        }
      }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._linkType) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._pageSize) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._pageToken) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._reverse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .targetFid(let v)? = self.target {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._linkType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pageSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pageToken {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._reverse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LinksByTargetRequest, rhs: LinksByTargetRequest) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs._linkType != rhs._linkType {return false}
    if lhs._pageSize != rhs._pageSize {return false}
    if lhs._pageToken != rhs._pageToken {return false}
    if lhs._reverse != rhs._reverse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdRegistryEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdRegistryEventRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.fid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fid != 0 {
      try visitor.visitSingularUInt64Field(value: self.fid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdRegistryEventRequest, rhs: IdRegistryEventRequest) -> Bool {
    if lhs.fid != rhs.fid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdRegistryEventByAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdRegistryEventByAddressRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdRegistryEventByAddressRequest, rhs: IdRegistryEventByAddressRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
