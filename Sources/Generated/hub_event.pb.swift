// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: hub_event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum HubEventType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case mergeMessage // = 1
  case pruneMessage // = 2
  case revokeMessage // = 3
  case mergeIDRegistryEvent // = 4
  case mergeNameRegistryEvent // = 5
  case mergeUsernameProof // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .mergeMessage
    case 2: self = .pruneMessage
    case 3: self = .revokeMessage
    case 4: self = .mergeIDRegistryEvent
    case 5: self = .mergeNameRegistryEvent
    case 6: self = .mergeUsernameProof
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .mergeMessage: return 1
    case .pruneMessage: return 2
    case .revokeMessage: return 3
    case .mergeIDRegistryEvent: return 4
    case .mergeNameRegistryEvent: return 5
    case .mergeUsernameProof: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension HubEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [HubEventType] = [
    .none,
    .mergeMessage,
    .pruneMessage,
    .revokeMessage,
    .mergeIDRegistryEvent,
    .mergeNameRegistryEvent,
    .mergeUsernameProof,
  ]
}

#endif  // swift(>=4.2)

struct MergeMessageBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: Message {
    get {return _storage._message ?? Message()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var deletedMessages: [Message] {
    get {return _storage._deletedMessages}
    set {_uniqueStorage()._deletedMessages = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PruneMessageBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: Message {
    get {return _message ?? Message()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: Message? = nil
}

struct RevokeMessageBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: Message {
    get {return _message ?? Message()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: Message? = nil
}

struct MergeIdRegistryEventBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var idRegistryEvent: IdRegistryEvent {
    get {return _idRegistryEvent ?? IdRegistryEvent()}
    set {_idRegistryEvent = newValue}
  }
  /// Returns true if `idRegistryEvent` has been explicitly set.
  var hasIDRegistryEvent: Bool {return self._idRegistryEvent != nil}
  /// Clears the value of `idRegistryEvent`. Subsequent reads from it will return its default value.
  mutating func clearIDRegistryEvent() {self._idRegistryEvent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _idRegistryEvent: IdRegistryEvent? = nil
}

struct MergeNameRegistryEventBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nameRegistryEvent: NameRegistryEvent {
    get {return _nameRegistryEvent ?? NameRegistryEvent()}
    set {_nameRegistryEvent = newValue}
  }
  /// Returns true if `nameRegistryEvent` has been explicitly set.
  var hasNameRegistryEvent: Bool {return self._nameRegistryEvent != nil}
  /// Clears the value of `nameRegistryEvent`. Subsequent reads from it will return its default value.
  mutating func clearNameRegistryEvent() {self._nameRegistryEvent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nameRegistryEvent: NameRegistryEvent? = nil
}

struct MergeUserNameProofBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var usernameProof: UserNameProof {
    get {return _usernameProof ?? UserNameProof()}
    set {_usernameProof = newValue}
  }
  /// Returns true if `usernameProof` has been explicitly set.
  var hasUsernameProof: Bool {return self._usernameProof != nil}
  /// Clears the value of `usernameProof`. Subsequent reads from it will return its default value.
  mutating func clearUsernameProof() {self._usernameProof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _usernameProof: UserNameProof? = nil
}

struct HubEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: HubEventType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var body: OneOf_Body? {
    get {return _storage._body}
    set {_uniqueStorage()._body = newValue}
  }

  var mergeMessageBody: MergeMessageBody {
    get {
      if case .mergeMessageBody(let v)? = _storage._body {return v}
      return MergeMessageBody()
    }
    set {_uniqueStorage()._body = .mergeMessageBody(newValue)}
  }

  var pruneMessageBody: PruneMessageBody {
    get {
      if case .pruneMessageBody(let v)? = _storage._body {return v}
      return PruneMessageBody()
    }
    set {_uniqueStorage()._body = .pruneMessageBody(newValue)}
  }

  var revokeMessageBody: RevokeMessageBody {
    get {
      if case .revokeMessageBody(let v)? = _storage._body {return v}
      return RevokeMessageBody()
    }
    set {_uniqueStorage()._body = .revokeMessageBody(newValue)}
  }

  var mergeIDRegistryEventBody: MergeIdRegistryEventBody {
    get {
      if case .mergeIDRegistryEventBody(let v)? = _storage._body {return v}
      return MergeIdRegistryEventBody()
    }
    set {_uniqueStorage()._body = .mergeIDRegistryEventBody(newValue)}
  }

  var mergeNameRegistryEventBody: MergeNameRegistryEventBody {
    get {
      if case .mergeNameRegistryEventBody(let v)? = _storage._body {return v}
      return MergeNameRegistryEventBody()
    }
    set {_uniqueStorage()._body = .mergeNameRegistryEventBody(newValue)}
  }

  var mergeUsernameProofBody: MergeUserNameProofBody {
    get {
      if case .mergeUsernameProofBody(let v)? = _storage._body {return v}
      return MergeUserNameProofBody()
    }
    set {_uniqueStorage()._body = .mergeUsernameProofBody(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Body: Equatable {
    case mergeMessageBody(MergeMessageBody)
    case pruneMessageBody(PruneMessageBody)
    case revokeMessageBody(RevokeMessageBody)
    case mergeIDRegistryEventBody(MergeIdRegistryEventBody)
    case mergeNameRegistryEventBody(MergeNameRegistryEventBody)
    case mergeUsernameProofBody(MergeUserNameProofBody)

  #if !swift(>=4.1)
    static func ==(lhs: HubEvent.OneOf_Body, rhs: HubEvent.OneOf_Body) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.mergeMessageBody, .mergeMessageBody): return {
        guard case .mergeMessageBody(let l) = lhs, case .mergeMessageBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pruneMessageBody, .pruneMessageBody): return {
        guard case .pruneMessageBody(let l) = lhs, case .pruneMessageBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.revokeMessageBody, .revokeMessageBody): return {
        guard case .revokeMessageBody(let l) = lhs, case .revokeMessageBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mergeIDRegistryEventBody, .mergeIDRegistryEventBody): return {
        guard case .mergeIDRegistryEventBody(let l) = lhs, case .mergeIDRegistryEventBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mergeNameRegistryEventBody, .mergeNameRegistryEventBody): return {
        guard case .mergeNameRegistryEventBody(let l) = lhs, case .mergeNameRegistryEventBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mergeUsernameProofBody, .mergeUsernameProofBody): return {
        guard case .mergeUsernameProofBody(let l) = lhs, case .mergeUsernameProofBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension HubEventType: @unchecked Sendable {}
extension MergeMessageBody: @unchecked Sendable {}
extension PruneMessageBody: @unchecked Sendable {}
extension RevokeMessageBody: @unchecked Sendable {}
extension MergeIdRegistryEventBody: @unchecked Sendable {}
extension MergeNameRegistryEventBody: @unchecked Sendable {}
extension MergeUserNameProofBody: @unchecked Sendable {}
extension HubEvent: @unchecked Sendable {}
extension HubEvent.OneOf_Body: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension HubEventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HUB_EVENT_TYPE_NONE"),
    1: .same(proto: "HUB_EVENT_TYPE_MERGE_MESSAGE"),
    2: .same(proto: "HUB_EVENT_TYPE_PRUNE_MESSAGE"),
    3: .same(proto: "HUB_EVENT_TYPE_REVOKE_MESSAGE"),
    4: .same(proto: "HUB_EVENT_TYPE_MERGE_ID_REGISTRY_EVENT"),
    5: .same(proto: "HUB_EVENT_TYPE_MERGE_NAME_REGISTRY_EVENT"),
    6: .same(proto: "HUB_EVENT_TYPE_MERGE_USERNAME_PROOF"),
  ]
}

extension MergeMessageBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MergeMessageBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .standard(proto: "deleted_messages"),
  ]

  fileprivate class _StorageClass {
    var _message: Message? = nil
    var _deletedMessages: [Message] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _message = source._message
      _deletedMessages = source._deletedMessages
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._message) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._deletedMessages) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._message {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._deletedMessages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._deletedMessages, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MergeMessageBody, rhs: MergeMessageBody) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._message != rhs_storage._message {return false}
        if _storage._deletedMessages != rhs_storage._deletedMessages {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PruneMessageBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PruneMessageBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PruneMessageBody, rhs: PruneMessageBody) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RevokeMessageBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RevokeMessageBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RevokeMessageBody, rhs: RevokeMessageBody) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MergeIdRegistryEventBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MergeIdRegistryEventBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_registry_event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._idRegistryEvent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._idRegistryEvent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MergeIdRegistryEventBody, rhs: MergeIdRegistryEventBody) -> Bool {
    if lhs._idRegistryEvent != rhs._idRegistryEvent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MergeNameRegistryEventBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MergeNameRegistryEventBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "name_registry_event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nameRegistryEvent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nameRegistryEvent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MergeNameRegistryEventBody, rhs: MergeNameRegistryEventBody) -> Bool {
    if lhs._nameRegistryEvent != rhs._nameRegistryEvent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MergeUserNameProofBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MergeUserNameProofBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "username_proof"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._usernameProof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._usernameProof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MergeUserNameProofBody, rhs: MergeUserNameProofBody) -> Bool {
    if lhs._usernameProof != rhs._usernameProof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HubEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HubEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .standard(proto: "merge_message_body"),
    4: .standard(proto: "prune_message_body"),
    5: .standard(proto: "revoke_message_body"),
    6: .standard(proto: "merge_id_registry_event_body"),
    7: .standard(proto: "merge_name_registry_event_body"),
    8: .standard(proto: "merge_username_proof_body"),
  ]

  fileprivate class _StorageClass {
    var _type: HubEventType = .none
    var _id: UInt64 = 0
    var _body: HubEvent.OneOf_Body?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _id = source._id
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 3: try {
          var v: MergeMessageBody?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .mergeMessageBody(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .mergeMessageBody(v)
          }
        }()
        case 4: try {
          var v: PruneMessageBody?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .pruneMessageBody(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .pruneMessageBody(v)
          }
        }()
        case 5: try {
          var v: RevokeMessageBody?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .revokeMessageBody(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .revokeMessageBody(v)
          }
        }()
        case 6: try {
          var v: MergeIdRegistryEventBody?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .mergeIDRegistryEventBody(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .mergeIDRegistryEventBody(v)
          }
        }()
        case 7: try {
          var v: MergeNameRegistryEventBody?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .mergeNameRegistryEventBody(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .mergeNameRegistryEventBody(v)
          }
        }()
        case 8: try {
          var v: MergeUserNameProofBody?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .mergeUsernameProofBody(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .mergeUsernameProofBody(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._type != .none {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 2)
      }
      switch _storage._body {
      case .mergeMessageBody?: try {
        guard case .mergeMessageBody(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .pruneMessageBody?: try {
        guard case .pruneMessageBody(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .revokeMessageBody?: try {
        guard case .revokeMessageBody(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .mergeIDRegistryEventBody?: try {
        guard case .mergeIDRegistryEventBody(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .mergeNameRegistryEventBody?: try {
        guard case .mergeNameRegistryEventBody(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .mergeUsernameProofBody?: try {
        guard case .mergeUsernameProofBody(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HubEvent, rhs: HubEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
